% for message in this.messages_order:
${this.messages[message].render(state)}
% endfor

${this.title(' ', this.name)}

cdef void serialize_${this.fullname}(object array, object self):
% for index, field in this.fields_required:
    serialize_type(array, ${field.get_tag(state)}, ${field.index})
% if field.type in field.TYPE_TAG:
    serialize_${field.type}(array, self.${field.name})
% else:
% set message = state.find_name(field.type)
    serialize_with_length_${message.fullname}(array, self.${field.name})
% endif
% endfor
% for index, field in this.fields_repeated:
    serialize_type(array, ${field.get_tag(state)}, ${field.index})
    field_buff = bytearray()
    for item in self.${field.name}:
% if field.type in field.TYPE_TAG:
        serialize_${field.type}(field_buff, item)
% else:
% set message = state.find_name(field.type)
        serialize_with_length_${message.fullname}(field_buff, item)
% endif
    serialize_uint64(array, PyByteArray_GET_SIZE(field_buff))
    PySequence_InPlaceConcat(array, field_buff)
% endfor
% for index, field in this.fields_optional:
    if hasattr(self, "${field.name}"):
        serialize_type(array, ${field.get_tag(state)}, ${field.index})
% if field.type in field.TYPE_TAG:
        serialize_${field.type}(array, self.${field.name})
% else:
% set message = state.find_name(field.type)
        serialize_with_length_${message.fullname}(array, self.${field.name})
% endif
% endfor
    pass

cdef void serialize_with_length_${this.fullname}(object array, object self):
    buff = bytearray()
    serialize_${this.fullname}(buff, self);
    serialize_uint64(array, PyByteArray_GET_SIZE(buff))
    PySequence_InPlaceConcat(array, buff)

cdef parsefunc __table_${this.fullname}[${this.max_index+1}]
% for index in range(0, this.max_index+1):
% if index in this.fields_by_index:
% set field = this.fields_by_index[index]
% if field.type in field.TYPE_TAG:
% if this.fields_by_index[index].kind == 'repeated':
__table_${this.fullname}[${index}] = repeat_deserialize_${field.type}
% else:
__table_${this.fullname}[${index}] = deserialize_${field.type}
% endif
% else:
% set message = state.find_name(field.type)
% if this.fields_by_index[index].kind == 'repeated':
__table_${this.fullname}[${index}] = repeat_deserialize_${message.fullname}
% else:
__table_${this.fullname}[${index}] = deserialize_${message.fullname}
% endif
% endif
% else:
__table_${this.fullname}[${index}] = NULL
% endif
% endfor

cdef char *__names_${this.fullname}[${this.max_index+1}]
% for index in range(0, this.max_index+1):
% if index in this.fields_by_index:
__names_${this.fullname}[${index}] = "${this.fields_by_index[index].name}"
% else:
__names_${this.fullname}[${index}] = NULL
% endif
% endfor

cdef object deserialize_${this.fullname}(char **start, char *end):
    cdef uint64_t n, t, size
    cdef uint32_t type
    cdef object self = object.__new__(${this.fullname})
    cdef char *other_start
    cdef parsefunc decoder
    cdef char *name
    while start[0]<end:
        if raw_deserialize_type(start, end, &type):
            raise DecodeError()
        n = type >> 3
        t = type & 7
        if n > ${this.max_index}:
            raise DecodeError()
        name = __names_${this.fullname}[n]
        if name == NULL:
            decoder = __decoder_bytype[t]
            if t == 2:
                if raw_deserialize_uint64(start, end, &size):
                    raise DecodeError()
                decoder(start, start[0] + size)
            else:
                decoder(start, end)
        else:
            decoder = __table_${this.fullname}[n]
            if t == 2:
                if raw_deserialize_uint64(start, end, &size):
                    raise DecodeError()
                PyObject_SetAttrString(self, name,
                    decoder(start, start[0] + size)
                    )
            else:
                PyObject_SetAttrString(self, name,
                    decoder(start, end)
                    )
    return self

cdef object repeat_deserialize_${this.fullname}(char **start, char *end):
    cdef object value = []
    cdef uint64_t size
    while start[0] < end:
        if raw_deserialize_uint64(start, end, &size):
            raise DecodeError()
        value.append(deserialize_${this.fullname}(
            start, start[0] + size))
    return value

cdef object wrapped_deserialize_${this.fullname}(object array):
    cdef char *buff = PyByteArray_AS_STRING(array)
    cdef Py_ssize_t size = PyByteArray_GET_SIZE(array)
    return deserialize_${this.fullname}(&buff, buff + size)
